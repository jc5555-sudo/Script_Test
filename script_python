#!/usr/bin/env python3

import os
import csv
import re
import glob
import sys

# ==================================================
# CONFIGURATION
# ==================================================
DEFAULT_LOG_PATTERN = '/home/inf25/work/fc_script/test4/logs_fc/*.log'

# Allow user to override input path
LOG_PATTERN = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_LOG_PATTERN

# Output is ALWAYS at execution path
OUTPUT_DIR = os.path.join(os.getcwd(), 'logs_report')

HEADER = ['Code', 'Severity', 'Description', 'User Severity', 'rpt msg', 'solution']

# ==================================================
# SETUP
# ==================================================
os.makedirs(OUTPUT_DIR, exist_ok=True)

log_files = sorted(glob.glob(LOG_PATTERN))

if not log_files:
    print(f"ERROR: No .log files found for pattern:\n  {LOG_PATTERN}")
    sys.exit(1)

print(f"Found {len(log_files)} log file(s)")
print(f"Writing reports to: {OUTPUT_DIR}")

# ==================================================
# PARSER
# ==================================================
def parse_log_file(log_file):
    rows = []

    try:
        with open(log_file, 'r', errors='ignore') as f:
            for line in f:
                line = line.strip()
                if line.startswith("Information:"):
                    m = re.search(r'(\w+-\d+)\s+(INFO|WARNING|ERROR)\s+(.*)', line)
                    if m:
                        rows.append([
                            m.group(1),
                            m.group(2).capitalize(),
                            '',
                            '',
                            m.group(3).strip(),
                            ''
                        ])
    except IOError as e:
        print(f"WARNING: Failed to read {log_file}: {e}")

    return rows


# ==================================================
# WRITERS
# ==================================================
def write_csv(path, rows):
    with open(path, 'w', newline='') as f:
        writer = csv.writer(f)
        writer.writerow(HEADER)
        writer.writerows(rows)


def write_html(path, rows, title):
    with open(path, 'w') as f:
        f.write('<html><head><meta charset="UTF-8">')
        f.write(f'<title>{title}</title>')
        f.write('</head><body>')
        f.write(f'<h2>{title}</h2>')
        f.write('<table border="1" cellpadding="4" cellspacing="0">')
        f.write('<tr>' + ''.join(f'<th>{h}</th>' for h in HEADER) + '</tr>')

        for row in rows:
            f.write('<tr>' + ''.join(f'<td>{c}</td>' for c in row) + '</tr>')

        f.write('</table></body></html>')


# ==================================================
# MAIN
# ==================================================
for log_path in log_files:
    filename = os.path.basename(log_path)
    base = os.path.splitext(filename)[0]

    print(f"\nProcessing: {log_path}")

    rows = parse_log_file(log_path)

    csv_path = os.path.join(OUTPUT_DIR, base + '.csv')
    html_path = os.path.join(OUTPUT_DIR, base + '.html')

    write_csv(csv_path, rows)
    write_html(html_path, rows, title=f"Log Report - {filename}")

    print(f"  → {base}.csv ({len(rows)} rows)")
    print(f"  → {base}.html")

print("\n✔ All log files processed successfully")
